# Controle de falhas

**Circuit Breaker**

Existem hoje um conjunto de ferramentas que, utilizadas em conjunto, podem nos ajudar a manter a capacidade de lidar com problemas e adaptar-nos a mudanÃ§as. Isso Ã© o que chamamos de *ResiliÃªncia*.

O *Circuit Breaker* Ã© implementado atravÃ©s de uma mÃ¡quina de estados finitos com trÃªs estados normais:

- ğŸŸ¢ **CLOSED**: Representa o status normal da aplicaÃ§Ã£o, onde cada camada atua como esperado, sejam serviÃ§os externos ou internos Ã  sua infraestrutura;

- ğŸ”´ **OPEN**: Representa status a partir da identificaÃ§Ã£o de alguma anomalia, alguma camada que nÃ£o estÃ¡ respondendo informaÃ§Ãµes como esperado ou que ficou inoperante;

- ğŸŸ¡ **HALFOPEN**: Representa o _status intermediÃ¡rio e indica que o circuito jÃ¡ esteve no status OPEN e que estÃ¡ validando a possibilidade de se tornar CLOSED, dependendo da janela a ser observada.

âš ï¸ *AtenÃ§Ã£o*: Janela Ã© a configuraÃ§Ã£o que pode ser definida por quantidade de operaÃ§Ãµes ou um tempo fixo.



### Vejamos uma camada de serviÃ§o que invoca um banco de dados (camada de 
persistÃªncia) para listar registros salvos na base de dados:

```java
public List<Pessoa> listarPessoas() {
  return bancoDeDados.findAll();
}
```


Para a aplicaÃ§Ã£o, o serviÃ§o de banco de dados Ã© um ponto de falha e, caso esteja indisponÃ­vel
utilizaremos uma das bibliotecas destinadas para tratar falhas, conhecida como resilience-4j

```xml
<dependency>
  <groupId>io.github.resilience4j</groupId>
  <artifactId>resilience4j-all</artifactId>
  <version>2.0.2</version>
</dependency>
<dependency>
<groupId>io.github.resilience4j</groupId>
<artifactId>resilience4j-spring-boot2</artifactId>
<version>2.0.2</version>
</dependency>
```

ğŸ–ŠAnote aÃ­: no exemplo, consideramos o uso da biblioteca original, mas o 
resilience-4j tambÃ©m pode ser encontrada internamente dentro do Spring Cloud
atravÃ©s da dependÃªncia spring-cloud-starter-circuitbreaker-resilience4j.

[Resilience4j Documentation](https://resilience4j.readme.io/)


### O que deveria ser alterado no mÃ©todo citado para garantir que o fluxo passasse a ser monitorado por um circuit breaker?

```java
@CircuitBreaker(name = "pessoas")
public List<Pessoa> listarPessoas() {
  return pessoaRepository.findAll();
}
```

Agora vamos configurar o arquivo **application.yml**  localizado na pasta resources do projeto.


```yaml
resilience4j.circuitbreaker:
  configs:
    default:
      waitDurationInOpenState: 10s
      failureRateThreshold: 10
  instances:
    pessoas:
      baseConfig: default
```

As configuraÃ§Ãµes do Circuit Breaker sÃ£o as seguintes:

- `failureRateThreshold`: Taxa de erro esperada para que o circuito seja aberto (10%).

- `waitDurationInOpenState`: Tempo que o Circuit Breaker deve esperar antes de fazer a transiÃ§Ã£o de aberto para meio aberto (10 segundos).


Com isso, temos que o retorno do mÃ©todo deixaria de ser um possÃ­vel erro relacionado ao banco e passaria para algo como:
> CircuitBreaker **'pessoas'** is OPEN and does not permit further calls


# Fallback

> Ao termos uma funÃ§Ã£o anotada com @CircuitBreaker, temos a possibilidade de 
> informar qual serÃ¡ seu mÃ©todo de retorno em casos de falhas: o fallbackMethod.

>  importante lembrar que um mÃ©todo de fallback deve ser colocado na mesma 
> classe e deve ter a mesma sequÃªncia de argumentos. Opcionalmente, podemos acrescentar um parÃ¢metro de exceÃ§Ã£o.

```java
@CircuitBreaker(name = "pessoas", fallbackMethod = "fallback")
public List<Pessoa> listarPessoas(){
    return pessoaRepository.findAll();
    }

private List<Pessoa> fallback(RuntimeException e){
    return List.of();
    }
```

> Assim, em caso de erro o mÃ©todo fallback seria chamado pelo circuit breaker e
> o retorno seria uma lista vazia (List.of()).

[DocumentaÃ§Ã£o do Retry no Resilience4j](https://resilience4j.readme.io/docs/retry)





