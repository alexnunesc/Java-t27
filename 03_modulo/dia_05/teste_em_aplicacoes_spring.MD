# Testes em aplica√ß√µes Spring

### ***Testes em aplica√ß√µes REST***

> Suponha que tiv√©ssemos a rota a seguir em nossa aplica√ß√£o. Atrav√©s dela,
> conseguimos pegar os dados de uma pessoa estudante atrav√©s de um service:

```java
@GetMapping("/students/{id}")
// Este m√©todo √© um controlador que lida com solicita√ß√µes GET para "/students/{id}".

// O par√¢metro "id" √© anotado com @PathVariable, o que significa que seu valor ser√° extra√≠do
// automaticamente a partir do segmento de URL correspondente na solicita√ß√£o HTTP.

// O objetivo deste m√©todo √© obter as informa√ß√µes de um estudante com base no ID fornecido na URL.
public ResponseEntity<Student> getStudent(@PathVariable Long id) {
    // 1. Obt√©m um estudante com base no ID fornecido, retornando um Optional<Student>.
    Optional<Student> optionalStudent = service.getStudent(id);

    // 2. Verifica se um estudante foi encontrado.
    return optionalStudent
    // 3. Se um estudante foi encontrado, cria uma resposta HTTP 200 (OK) com o estudante encontrado.
    .map(student -> ResponseEntity.ok(student))
    // 4. Se nenhum estudante foi encontrado, cria uma resposta HTTP 404 (Not Found).
    .orElse(ResponseEntity.notFound().build());
    }

```

# RestTemplate vs MockMvc

> Classes **RestTemplate** e **MockMvc**.

Anota a√≠ üìù: a **RestTemplate** precisa que o servidor seja realmente executado para os testes, enquanto a **MockMvc** apenas simula as requisi√ß√µes, sem necessidade do servidor.

Anota a√≠ üìù:

- O Spring garante que o servidor est√° sendo executado.
- N√≥s s√≥ precisamos implementar o cliente em nossos testes.
- Para isso, podemos utilizar a classe **RestTemplate**.
- O principal objetivo da classe **RestTemplate** √© fazer requisi√ß√µes REST, n√£o s√≥ para testes, mas em qualquer caso.


Por√©m o melhor para economizar √© usar o **MockMvc**

# Usando RestTemplate:

- Com o uso do **RestTemplate**, podemos indicar a URL da nossa API.
- Podemos efetuar a chamada correspondente ao verbo HTTP previamente indicado.
- Para uma requisi√ß√£o GET, usamos a fun√ß√£o `getForEntity`.
- Para testar uma fun√ß√£o do tipo POST, usar√≠amos `postForEntity`.


```java
// Anota√ß√£o para configurar este como um teste Spring Boot em um ambiente com porta definida.
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
class StudentsApplicationTests {

  // Inje√ß√£o de depend√™ncia do RestTemplate para fazer chamadas HTTP.
  @Autowired
  private RestTemplate restTemplate;

  // M√©todo de teste para verificar a chamada GET a um aluno espec√≠fico.
  @Test
  void testGetStudentById() {
    // Faz uma chamada HTTP GET para o URL "http://localhost:8080/students/123" e armazena a resposta.
    ResponseEntity<Student> response = restTemplate.getForEntity(
        "http://localhost:8080/students/123", Student.class);

    // Verifica se o c√≥digo de status HTTP na resposta √© igual a HttpStatus.OK (200).
    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

    // Verifica se o corpo da resposta (objeto Student) n√£o √© nulo.
    assertThat(response.getBody()).isNotNull();
  }
}

```

### No teste apresentado acima, temos:

1. Indica√ß√£o que queremos que o servidor de teste seja executado na porta padr√£o, que √© 8080 no nosso caso, embora tamb√©m seja poss√≠vel usar uma porta aleat√≥ria.

2. Inje√ß√£o de um bean do **RestTemplate**, que √© uma inst√¢ncia que permite fazer requisi√ß√µes HTTP em nossos testes.

3. Realiza√ß√£o de uma requisi√ß√£o para uma URL espec√≠fica, aguardando um objeto do tipo **Student** como resposta.

4. Verifica√ß√£o do status code 200 (OK), indicando que a requisi√ß√£o foi bem-sucedida, e verifica√ß√£o da exist√™ncia do corpo da resposta.

> Nesse exemplo, estamos usando o assertThat do AssertJ, uma depend√™ncia que o Spring Boot traz. Poder√≠amos utilizar os m√©todos do pr√≥prio JUnit como o assertEquals

Mas uma forma alternativa (que estamos utilizando) √© simplesmente transform√°-la em um bean.

```java
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```

Uma √∫ltima nota sobre a RestTemplate: nas vers√µes mais recentes do Spring ela 
vem sido gradualmente substitu√≠da pelo uso da classe **WebClient**.


# Usando MockMvc

>Com o uso da MockMvc, podemos indicar ao Spring boot que n√£o ser√° 
> necess√°rio iniciar o servidor.

Para podermos utilizar a **MockMvc**
usamos a anota√ß√£o **@AutoConfigureMockMvc**


# Isolando testes de camadas com @MockBean


Uma das anota√ß√µes que a Mockito disponibiliza √© a @MockBean. Ela permite que n√≥s
controlemos as chamadas para beans que s√£o injetados pelo Spring.


No nosso exemplo inicial, a rota GET foi definida pelo m√©todo getStudent do controller, que chamava o m√©todo de um service. Vamos supor que esse service √© um bean controlado pelo Spring:

```java
@RestController
public class StudentsController {
  
  StudentsService service;

  @Autowired
  public StudentsController(StudentsService service) {
    this.service = service;
  }

  // ... restante da classe ...

}
```

E se quis√©ssemos isolar o teste, focando na camada de controle? 

Entra o **@MockBean**

```java
@SpringBootTest
@AutoConfigureMockMvc
class StudentsApplicationMockBeanTests {
  @Autowired
  private MockMvc mockMvc;

  @MockBean
  private StudentsService service; // (1)

  @Test
  void testStudentNotFound() throws Exception {
    Mockito
        .when(service.getStudent(123L))
        .thenReturn(Optional.empty());  // (2)

    ResultActions result = mockMvc.perform(  // (3)
        get("/students/123"));

    result.andExpect(status().isNotFound());
  
    Mockito.verify(service).getStudent(123L);  // (4)
  }
}
```

No exemplo acima, fizemos o seguinte:

1. Primeiro (1), definimos o servi√ßo (`StudentsService`) e anotamos com `@MockBean`. Isso substitui o bean injetado no controlador pelo nosso mock. Qualquer chamada feita pelo controlador ao servi√ßo ser√° redirecionada para o nosso mock.

2. Segundo (2), antes de realizar a chamada √† rota (usando o `mockMvc`), configuramos nosso mock para que, se o servi√ßo fosse chamado com `.getStudent(123L)`, ele retornaria `Optional.empty()`. Isso simula um cen√°rio em que o servi√ßo n√£o encontra um estudante com o ID 123.

3. Terceiro (3), fizemos a chamada √† API normalmente. No entanto, devido √† configura√ß√£o do mock do servi√ßo, esperamos que a rota retorne um c√≥digo de status 404 (n√£o encontrado), indicando que o estudante n√£o foi encontrado.

4. Por fim (4), utilizamos o Mockito para verificar se o mock do servi√ßo foi chamado conforme esperado. Isso nos permite garantir que o controlador n√£o tenha alcan√ßado uma resposta correta por outros meios, sem usar o servi√ßo. √â um teste adicional para verificar a intera√ß√£o correta entre o controlador e o servi√ßo.
